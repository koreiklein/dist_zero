import shutil
import os
import tempfile
import importlib
import sys

from . import expression, statement
from .common import INDENT, escape_c


class Function(expression.Expression):
  def __init__(self, program, name, retType, args, export=False, docstring=''):
    self.program = program
    self.name = name
    self.export = export
    self.docstring = docstring
    self.retType = retType
    self.args = args
    self._block = statement.Block(self.program, root=True)

  def to_c_string(self, root=False):
    return self.name

  def add_includes(self, program):
    pass

  def AddReturn(self, *args, **kwargs):
    return self._block.AddReturn(*args, **kwargs)

  def AddIf(self, *args, **kwargs):
    return self._block.AddIf(*args, **kwargs)

  def AddDeclaration(self, *args, **kwargs):
    return self._block.AddDeclaration(*args, **kwargs)

  def AddAssignment(self, *args, **kwargs):
    return self._block.AddAssignment(*args, **kwargs)

  def header_string(self):
    args = ", ".join([arg.type.wrap_variable(arg.name) for arg in self.args])
    static = 'static ' if self.export else ''
    return f"{static}{self.retType.wrap_variable(self.name)} ({args})\n"

  def function_to_c_string(self, lines):
    lines.append(self.header_string())

    self._block.to_c_string(lines, 0)


class Program(object):
  def __init__(self, name, docstring=''):
    self.name = name
    self.docstring = docstring
    self._function_names = set()
    self._functions = []
    self._exported_functions = []
    self.includes = set()

    self.includes.add("<Python.h>")

  def cfilename(self):
    return f"{self.name}.c"

  def build_and_import(self):
    full_name = self.build_so("./cextensions")
    return importlib.import_module(f"cextensions.{self.name}", self.name)

  def build_so(self, dirname):
    '''
        Build this program and write the resulting so file to dirname.
        Return the fully qualified path to the so.
        '''
    tempdir = tempfile.mkdtemp()

    # Generate the c file
    cfilename = os.path.join(tempdir, self.cfilename())
    with open(cfilename, 'w') as f:
      f.write(self.to_c_string())

    # Write a quick distutils file that describes how to compile the c file into a python extension
    distutilsfilename = os.path.join(tempdir, "setup.py")
    with open(distutilsfilename, 'w') as f:
      f.write("from distutils.core import setup, Extension\n")
      f.write(f'module = Extension("{self.name}",\n')
      f.write(f'{INDENT * " "}sources=[\n')
      f.write(f'{INDENT * 2 * " "}"{cfilename}",\n')
      f.write(f'{INDENT * " "}],\n')
      f.write(f'{INDENT * " "}include_dirs=[\n')
      f.write(f'{INDENT * " "}],\n')
      f.write(f')\n\n')
      f.write(
          f'setup(name="{self.name}", version="0.1", description="Autogenerated python package", ext_modules=[module])\n'
      )

    # Build the extension in the temporary directory
    if 0 != os.system(f'cd {tempdir} && python setup.py build > /dev/null'):
      raise RuntimeError("Error building c extension.")

    # Copy the resulting so file into the desired output directory.
    builddir = os.path.join(tempdir, "build")
    archdir = self.distutils_arch_dir(builddir)
    so_filename = self.distutils_so_filename(archdir)
    shutil.copyfile(os.path.join(archdir, so_filename), os.path.join(dirname, so_filename))
    return so_filename

  def distutils_arch_dir(self, builddir):
    contents = os.listdir(builddir)
    if len(contents) != 2:
      raise RuntimeError(f"Expected exactly 2 subdirectories in the build directory.  Got {len(contents)}.")
    for d in contents:
      if d.startswith('lib'):
        return os.path.join(builddir, d)

    raise RuntimeError(f"Could not find a lib.* directory in the build directory.  Got {contents}.")

  def distutils_so_filename(self, archdir):
    contents = os.listdir(archdir)
    if len(contents) != 1:
      raise RuntimeError(f"Expected exactly one file in the architecture directory.  Got {len(contents)}.")
    return contents[0]

  def AddFunction(self, name, retType, args, docstring='', export=False):
    if name in self._function_names:
      raise RuntimeError(f"A function with the name {name} has already been added to this c program.")
    self._function_names.add(name)
    result = Function(self, name, retType, args, docstring=docstring, export=export)
    self._functions.append(result)
    if export:
      self._exported_functions.append(result)
    return result

  def __str__(self):
    return self.to_c_string()

  def to_c_string(self):
    lines = []
    for include in self.includes:
      lines.append(f"#include {include}\n")
    lines.append("\n")

    for func in self._functions:
      func.function_to_c_string(lines)
      lines.append('\n')

    self.add_python_c_extension_boilerplate(lines)

    return ''.join(lines)

  def add_python_c_extension_boilerplate(self, lines):
    self.add_c_extension_exported_methods(lines)
    self.add_py_module_def(lines)
    self.add_py_module_init(lines)

  def add_py_module_init(self, lines):
    lines.append("PyMODINIT_FUNC\n")
    lines.append(f"PyInit_{self.name}(void) {{\n")
    lines.append(f"{' ' * INDENT}return PyModule_Create(&{self.module_name()});\n")
    lines.append("}\n\n")

  def add_py_module_def(self, lines):
    lines.append(f"static struct PyModuleDef {self.module_name()} = {{\n")
    lines.append(f"{' ' * INDENT}PyModuleDef_HEAD_INIT,\n")
    lines.append(f'{" " * INDENT}"{self.name}",\n')
    lines.append(f'{" " * INDENT}"{escape_c(self.docstring)}",\n')
    lines.append(f"{' ' * INDENT}-1,\n")
    lines.append(f"{' ' * INDENT}{self.method_array_name()}\n")
    lines.append("};\n\n")

  def method_array_name(self):
    return f"{self.name}_Methods"

  def module_name(self):
    return f"{self.name}_Module"

  def add_c_extension_exported_methods(self, lines):
    lines.append(f"static struct PyMethodDef {self.method_array_name()}[] = {{\n")
    for func in self._exported_functions:
      lines.append(f'{" " * INDENT}{{"{func.name}", {func.name}, METH_VARARGS, "{escape_c(func.docstring)}"}},\n')
    lines.append(f"{' ' * INDENT}{{NULL, NULL, 0, NULL}},\n")
    lines.append("};\n\n")
