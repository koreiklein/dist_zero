import importlib
import itertools
import os
import shutil
import subprocess
import tempfile

from . import expression, statement, type, lvalue, struct
from .common import INDENT, INDENT_TWO, escape_c


class Program(object):
  def __init__(self,
               name,
               docstring='',
               include_dirs=None,
               libraries=None,
               library_dirs=None,
               sources=None,
               includes=None):
    self.name = name
    self.docstring = docstring
    self._python_types = []
    self._function_names = set()
    self._functions = []
    self._exported_functions = []
    self._structures = []
    self._enums = []
    self._unions = []
    self.includes = set()

    self._library_dirs = [] if library_dirs is None else library_dirs
    self._libraries = [] if libraries is None else libraries
    self._sources = [] if sources is None else sources

    self.includes.add("<Python.h>")
    if includes is not None:
      for include in includes:
        self.includes.add(include)

    self._include_dirs = ['include']
    if include_dirs is not None:
      self._include_dirs += include_dirs

  def cfilename(self):
    return f"{self.name}.c"

  def _package_name(self):
    return f"cextensions.{self.name}"

  def _module_name(self):
    return f"cextensions.{self.name}.{self.name}"

  def build_and_import(self):
    full_name = self.build_so("./cextensions")
    return importlib.import_module(self._package_name(), self.name)

  def build_so(self, dirname):
    '''
        Build this program and write the resulting so file to dirname.
        Return the fully qualified path to the so.
        '''
    tempdir = tempfile.mkdtemp()

    # Generate the c file
    cfilename = os.path.join(tempdir, self.cfilename())
    with open(cfilename, 'w') as f:
      # Uncomment the below line for some simple debugging
      #print(str(self))
      for line in self.to_c_string():
        f.write(line)

    # Write a quick distutils file that describes how to compile the c file into a python extension
    distutilsfilename = os.path.join(tempdir, "setup.py")
    with open(distutilsfilename, 'w') as f:
      f.write("from distutils.core import setup, Extension\n")
      f.write(f'module = Extension("{self.name}",\n')

      f.write(f'{INDENT}sources=[\n')
      f.write(f'{INDENT_TWO}"{cfilename}",\n')
      for source in self._sources:
        f.write(f'{INDENT_TWO}"{source}",\n')
      f.write(f'{INDENT}],\n')

      f.write(f'{INDENT}library_dirs=[\n')
      for lib in self._library_dirs:
        f.write(f'{INDENT_TWO}"{lib}",\n')
      f.write(f'{INDENT}],\n')

      f.write(f'{INDENT}libraries=[\n')
      for lib in self._libraries:
        f.write(f'{INDENT_TWO}"{lib}",\n')
      f.write(f'{INDENT}],\n')

      f.write(f'{INDENT}include_dirs=[\n')

      for include_dir in self._include_dirs:
        path = os.path.join(os.path.realpath("."), include_dir)
        f.write(f'{INDENT_TWO}"{path}",\n')

      f.write(f'{INDENT}],\n')
      f.write(f')\n\n')
      f.write(
          f'setup(name="{self.name}", version="0.1", description="Autogenerated python package", ext_modules=[module])\n'
      )

    # Build the extension in the temporary directory
    try:
      subprocess.check_output(['bash', '-c', f'cd {tempdir} && python setup.py build > /dev/null'],
                              stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
      try:
        with open(f'.tmp/{self.name}.errorfile.c', 'w') as f:
          for line in self.to_c_string():
            f.write(line)
      finally:
        raise RuntimeError(f"Error building c extension:\n{e.output.decode()}")

    # Copy the resulting so file into the desired output directory.
    builddir = os.path.join(tempdir, "build")
    archdir = self.distutils_arch_dir(builddir)
    so_filename = self.distutils_so_filename(archdir)
    shutil.copyfile(os.path.join(archdir, so_filename), os.path.join(dirname, so_filename))
    return so_filename

  def distutils_arch_dir(self, builddir):
    contents = os.listdir(builddir)
    if len(contents) != 2:
      raise RuntimeError(f"Expected exactly 2 subdirectories in the build directory.  Got {len(contents)}.")
    for d in contents:
      if d.startswith('lib'):
        return os.path.join(builddir, d)

    raise RuntimeError(f"Could not find a lib.* directory in the build directory.  Got {contents}.")

  def distutils_so_filename(self, archdir):
    contents = os.listdir(archdir)
    if len(contents) != 1:
      raise RuntimeError(f"Expected exactly one file in the architecture directory.  Got {len(contents)}.")
    return contents[0]

  def AddExternalFunction(self, name, args, docstring=''):
    fself = expression.Var('self', type.PyObject.Star())
    fargs = expression.Var('args', type.PyObject.Star())
    f = self.AddFunction(name, type.PyObject.Star(), [fself, fargs], export=True, docstring=docstring)

    f.generate_parse_external_args(args=args, mainArg=fargs)

    return f

  def AddPythonType(self, name, docstring=''):
    result = PythonType(program=self, name=name, docstring=docstring)
    self._python_types.append(result)
    return result

  def AddFunction(self, name, retType, args, docstring='', export=False):
    if name in self._function_names:
      raise RuntimeError(f"A function with the name {name} has already been added to this c program.")
    self._function_names.add(name)
    result = Function(self, name, retType, args, docstring=docstring, export=export)
    self._functions.append(result)
    if export:
      self._exported_functions.append(result)
    return result

  def AddEnum(self, name):
    result = struct.Enum(name)
    self._enums.append(result)
    return result

  def AddUnion(self, name):
    result = struct.Union(name)
    self._unions.append(result)
    return result

  def AddStruct(self, name):
    result = struct.Structure(name)
    self._structures.append(result)
    return result

  def __str__(self):
    return ''.join(self.to_c_string())

  def to_c_string(self):
    for x in itertools.chain(self._structures, self._unions):
      x.add_includes(self)

    for include in self.includes:
      yield f"#include {include}\n"
    yield "\n"

    for enum in self._enums:
      yield from enum.to_c_string_definition()
      yield '\n'

    for x in itertools.chain(self._structures, self._unions):
      yield f"{x.to_c_string()};\n"

    for union in self._unions:
      yield from union.to_c_string_definition()
      yield '\n'

    for structure in self._structures:
      yield from structure.to_c_string_definition()
      yield '\n'

    for python_type in self._python_types:
      yield from python_type.upper_part_to_c_string_definition()
      yield '\n'

    yield '\n'

    for func in self._functions:
      yield from func.function_to_c_string()
      yield '\n'

    for python_type in self._python_types:
      yield from python_type.lower_part_to_c_string_definition()
      yield '\n'

    yield from self.add_python_c_extension_boilerplate()

  def add_python_c_extension_boilerplate(self):
    yield from self.add_c_extension_exported_methods()
    yield from self.add_py_module_def()
    yield from self.add_py_module_init()

  def add_py_module_init(self):
    yield "PyMODINIT_FUNC\n"
    yield f"PyInit_{self.name}(void) {{\n"

    yield f"{INDENT}PyObject *module;\n\n"
    for python_type in self._python_types:
      yield f"{INDENT}if (PyType_Ready(&{python_type._type_definition_name()}) < 0) return NULL;\n"

    yield f"\n{INDENT}module = PyModule_Create(&{self.module_name()});\n"
    yield f"{INDENT}if (module == NULL) return NULL;\n\n"

    for python_type in self._python_types:
      t = python_type._type_definition_name()
      yield f"{INDENT}Py_INCREF(&{t});\n"
      yield f"{INDENT}PyModule_AddObject(module, \"{python_type.name}\", (PyObject *) &{t});\n"

    yield f"\n{INDENT}return module;\n"

    yield "}\n\n"

  def add_py_module_def(self):
    yield f"static struct PyModuleDef {self.module_name()} = {{\n"
    yield f"{INDENT}PyModuleDef_HEAD_INIT,\n"
    yield f'{INDENT}"{self.name}",\n'
    yield f'{INDENT}"{escape_c(self.docstring)}",\n'
    yield f"{INDENT}-1,\n"
    yield f"{INDENT}{self.method_array_name()}\n"
    yield "};\n\n"

  def method_array_name(self):
    return f"{self.name}_Methods"

  def module_name(self):
    return f"{self.name}_Module"

  def add_c_extension_exported_methods(self):
    yield f"static struct PyMethodDef {self.method_array_name()}[] = {{\n"
    for func in self._exported_functions:
      yield f'{INDENT}{{"{func.name}", {func.name}, METH_VARARGS, "{escape_c(func.docstring)}"}},\n'
    yield f"{INDENT}{{NULL, NULL, 0, NULL}},\n"
    yield "};\n\n"


class Function(expression.Expression):
  def __init__(self, program, name, retType, args, export=False, docstring=''):
    self.program = program
    self.name = name
    self.export = export
    self.docstring = docstring
    self.retType = retType
    self.args = args
    self._block = statement.Block(self.program, root=True)

  def SelfArg(self):
    if len(self.args) >= 1 and self.args[0].name == 'self':
      return self.args[0]
    else:
      raise RuntimeError("Function does not have a first 'self' argument")

  def ArgsArg(self):
    if len(self.args) >= 2 and self.args[1].name == 'args':
      return self.args[1]
    else:
      raise RuntimeError("Function does not have a second 'args' argument")

  def generate_parse_external_args(self, args, mainArg):
    for arg in args:
      self.AddDeclaration(lvalue.CreateVar(arg))

    format_string = expression.StrConstant(''.join(arg.type.parsing_format_string() for arg in args))
    whenParseFail = self.AddIf(
        expression.Call(expression.PyArg_ParseTuple,
                        [mainArg, format_string] + [arg.Address() for arg in args]).Negate()).consequent
    whenParseFail.AddReturn(expression.NULL)

  def to_c_string(self, root=False):
    return self.name

  def add_includes(self, program):
    pass

  def Newline(self):
    return self._block.Newline()

  def AddWhile(self, *args, **kwargs):
    return self._block.AddWhile(*args, **kwargs)

  def AddSwitch(self, *args, **kwargs):
    return self._block.AddSwitch(*args, **kwargs)

  def AddReturn(self, *args, **kwargs):
    return self._block.AddReturn(*args, **kwargs)

  def AddReturnVoid(self, *args, **kwargs):
    return self._block.AddReturnVoid(*args, **kwargs)

  def AddIf(self, *args, **kwargs):
    return self._block.AddIf(*args, **kwargs)

  def AddContinue(self, *args, **kwargs):
    return self._block.AddContinue(*args, **kwargs)

  def AddBreak(self, *args, **kwargs):
    return self._block.AddBreak(*args, **kwargs)

  def AddDeclaration(self, *args, **kwargs):
    return self._block.AddDeclaration(*args, **kwargs)

  def AddAssignment(self, *args, **kwargs):
    return self._block.AddAssignment(*args, **kwargs)

  def header_string(self):
    args = ", ".join([arg.type.wrap_variable(arg.name) for arg in self.args])
    static = 'static ' if self.export else ''
    return f"{static}{self.retType.wrap_variable(self.name)} ({args})\n"

  def function_to_c_string(self):
    yield self.header_string()

    yield from self._block.to_c_string('')


class PythonType(object):
  def __init__(self, program, name, docstring):
    self.program = program
    self.name = name
    self.docstring = docstring

    self.struct = struct.Structure(name, is_pyobject=True)

    self.methods = []

    self._init = None

  def _init_function_name(self):
    return f"{self.name}_init"

  def _self_arg(self):
    return expression.Var("self", self.struct.Star())

  def _args_arg(self):
    return expression.Var('args', type.PyObject.Star())

  def _static_method_array_name(self):
    return f"{self.name}_methods"

  def _emit_methods_and_static_method_array(self):
    for method in self.methods:
      yield from method.function_to_c_string()
      yield "\n"

    yield "\n"
    yield f"static PyMethodDef {self._static_method_array_name()}[] = {{\n"
    for method in self.methods:
      yield f'{INDENT}{{"{method.name}", (PyCFunction) {method.name}, METH_VARARGS, "{escape_c(method.docstring)}"}},\n'
    yield f"{INDENT}{{NULL}}\n"
    yield "};\n"

  def _type_definition_name(self):
    return f"{self.name}Type"

  def _emit_type_definition(self):
    yield f"static PyTypeObject {self._type_definition_name()} = {{\n"
    yield f"{INDENT}PyVarObject_HEAD_INIT(NULL, 0)\n"
    yield f"{INDENT}.tp_name = \"{self.program._module_name()}.{self.name}\",\n"
    yield f"{INDENT}.tp_doc = \"{self.docstring}\",\n"
    yield f"{INDENT}.tp_basicsize = sizeof({self.struct.to_c_string()}),\n"

    yield f"{INDENT}.tp_itemsize = 0,\n"
    yield f"{INDENT}.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\n"
    yield f"{INDENT}.tp_new = PyType_GenericNew,\n"
    if self._init:
      yield f"{INDENT}.tp_init = (initproc) {self._init_function_name()},\n"
    yield f"{INDENT}.tp_methods = {self._static_method_array_name()},\n"

    yield "};\n"

  def upper_part_to_c_string_definition(self):
    yield from self.struct.to_c_string_definition()

  def lower_part_to_c_string_definition(self):
    if self._init:
      yield from self._init.function_to_c_string()
      yield "\n"
    yield from self._emit_methods_and_static_method_array()
    yield "\n"
    yield from self._emit_type_definition()
    yield "\n"

  def AddMethod(self, name, args):
    mainArg = self._args_arg()
    result = Function(self.program, name, type.PyObject.Star(), [self._self_arg(), mainArg], export=True)

    if args is not None:
      result.generate_parse_external_args(args=args, mainArg=mainArg)

    self.methods.append(result)
    return result

  def AddInit(self):
    arg_kwargs = expression.Var('kwargs', type.PyObject.Star())
    mainArg = self._args_arg()

    result = Function(
        self.program, self._init_function_name(), type.MachineInt, [self._self_arg(), mainArg, arg_kwargs], export=True)
    self._init = result
    return result
