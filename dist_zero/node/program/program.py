import logging

from dist_zero import messages, errors
from dist_zero.node.node import Node
from .transactions import start_program

logger = logging.getLogger(__name__)


class ProgramNode(Node):
  '''
  Each `ProgramNode` instance is responsible for running a single distributed program.
  Typically, the configuration information for which program to run is generated by
  `DistributedProgram.to_program_node_config`.

  The `ProgramNode` will spawn all the relevant datasets and links, and make sure they keep running.
  '''

  def __init__(self, node_id, controller):
    self.id = node_id

    self._spy_key_to_ds_id = None # Should be populated by the transaction that starts this `ProgramNode`

    # self._datasets and self._links should both be populated by the transaction that starts this `ProgramNode`
    self._datasets = None # Map from dataset root `DataNode` id to its handle
    self._links = None # Map from link root `LinkNode` id to its handle

    self._controller = controller

    super(ProgramNode, self).__init__(logger)

  @staticmethod
  def from_config(node_config, controller):
    return ProgramNode(node_id=node_config['id'], controller=controller)

  def elapse(self, ms):
    pass

  def deliver(self, message, sequence_number, sender_id):
    pass

  def receive(self, message, sender_id):
    super(ProgramNode, self).receive(message=message, sender_id=sender_id)

  def handle_api_message(self, message):
    if message['type'] == 'get_spy_roots':
      return {key: self._datasets[ds_id] for key, ds_id in self._spy_key_to_ds_id.items()}
    elif message['type'] == 'get_datasets':
      return self._datasets
    elif message['type'] == 'get_links':
      return self._links
    elif message['type'] == 'link_datasets':
      link_config = message['link_config']
      self.start_transaction_eventually(
          start_program.StartLink(
              link_config=link_config,
              src=self._datasets[link_config['src_dataset_id']],
              tgt=self._datasets[link_config['tgt_dataset_id']],
          ))
    else:
      return super(ProgramNode, self).handle_api_message(message)
